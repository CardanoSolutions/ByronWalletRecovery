#!/usr/bin/env node

// Install:
//
// npm i cbor bech32 cardano-crypto.js@6.1.1
//
// Usage:
//
//    [node] ./index.js <FILEPATH> [USERPASSWORD] [LEGACYADDRESS]

//
// Example #1: no user password and legacy addresses are provided
//      It will list all wallets when user password and legacy addres are not provided.
//
//     ./index.js "examples/iog_secret_iog.key "" "DdzFFzCqrht3HPYUiN4jnDyXBaWTMdikTZxdnojP3kxHBuvFB7QjbaYriFFfPLqHY622aCXAqKrq34xNNe1rvkW4uAGFUDtDrX4yQRaR"
//
// Example #2: no user password and legacy addresses are provided
//    It will list only the wallet in which the legacy address belongs to. You must submit a
//    user password, even if the user does not have any (apply an empty string in that  case)
//
//     node ./index.js "examples/iog_secret_iog.key "" "DdzFFzCqrht3HPYUiN4jnDyXBaWTMdikTZxdnojP3kxHBuvFB7QjbaYriFFfPLqHY622aCXAqKrq34xNNe1rvkW4uAGFUDtDrX4yQRaR"
//
const cbor = require('cbor');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const {
  bech32
} = require('bech32');
const cardano = require('cardano-crypto.js')

const MAGIC = 764824073; // Mainnet MAGIC

// The user's password is for encryption/decrytpion of the master private key.
const [_1, _2, keystorePath, encryptionPassword, legacyAddress] = process.argv;

const bytes = fs.readFileSync(path.isAbsolute(keystorePath) ?
  keystorePath :
  path.join(__dirname, keystorePath));

const restoreParams = {
  encryptionPassword: encryptionPassword ? encryptionPassword : '',
  legacyAddress: legacyAddress ? legacyAddress : ''
}

decodeKeystore(bytes, restoreParams)
  .then(displayInformation)
  .then(console.log)
  .catch(console.exception);

async function toEncryptedSecretKey([encryptedPayload, passphraseHash], source, restoreParams) {

  const isEmptyPassphrase = isValidPassphrase(passphraseHash, "");

  // The payload is a concatenation of the private key, the public key
  // and the chain-code:
  //
  //      +---------------------------------+-----------------------+-----------------------+
  //      | Extended Private Key (64 bytes) | Public Key (32 bytes) | Chain Code (32 bytes) |
  //      +---------------------------------+-----------------------+-----------------------+
  //      <------------ ENCRYPTED ---------->
  //
  const esk = encryptedPayload.slice(0, 64);
  const xpub = encryptedPayload.slice(64, 128);
  const pk = xpub.slice(0, 32);
  const cc = encryptedPayload.slice(96);

  // Validate master private key encryption
  const {
    hasValidEncryption,
    decryptedSecret,
    encryptionPassword
  } = await isEncryptionValid(esk, pk, isEmptyPassphrase, restoreParams)

  // TODO: Check an edge case when the stored master public key cannot decrypt the derivation path
  // but the master public key from a decrypted secret key can. It should never happen in normal circumstances.
  // Check whether the address belongs to this wallet or not.
  const derivationParams = restoreParams.legacyAddress != '' ? await validateAddress(xpub, restoreParams.legacyAddress) : {
    path: undefined,
    passPhrase: undefined
  }
  const isWalletAddress = derivationParams.path ? derivationParams.path.length !== 0 : derivationParams.path

  // TODO: Check edge cases when the address could not be derived either from
  // the stored or the generated master secret. It can happen when the
  // derivation indexes are wrong, or if the chaincode is invalid or when the
  // address was generated by some other private key.
  /// These are very unlikely, but who knows?
  //
  // It returns undefined when address is not defined.
  // `pub` is god for concatenation as the decrypted and encrypted private key
  //  must have the same public key,
  const addressFromDecryptedKey = isWalletAddress === true ? validateDerivedAddress(Buffer.concat([decryptedSecret, pk, cc]), derivationParams, restoreParams) : undefined

  // Validate derivation
  return {
    // The XPrv(64+32) and XPub(32+32) is the extended secret/private key and
    // the normal Ed25519 public key concatenated with the corresponding chain
    // code.
    // See, details here: https://github.com/ilap/ShelleyStuffs#shelley-signing-keys
    xprv: Buffer.concat([esk, cc]),
    xpub,
    encryptedPayload,
    passphraseHash,
    isEmptyPassphrase,
    source,
    // Whether the encrypted master secret is decryptable
    // Yes or no.
    hasValidEncryption,
    // The password to decrypt the master secret. if it's '' then then encrypted master secret is already decrypte
    // undefined when the walled has invalid encryption
    encryptionPassword,
    // Whether the address belong to this wallet or not
    // Yes, not, and undefined when the user did not provide a byron address.
    isWalletAddress,
    path: derivationParams.path,
    // Whether it was derived from encrypted or decrypted master key
    // Yes, no and undefined when the address does not belong to this wallet
    addressFromDecryptedKey,
  };
}

// Keystores were always encrypted with a passphrase, at least on the server. For a while,
// the frontend (a.k.a Daedalus) did allow users to generate wallets with no encryption
// passphrase, in which case it used to send an empty string as a passphrase to the server.
//
// Thus, is possible to know if a passphrase is an "empty passphrase" by comparing it with
// a CBOR-serialized empty bytestring (`0x40`). The salt used for encryption is embedded in
// passphrase.
function isValidPassphrase(passwordHash, encryptionPassword) {

  const cborBytes = cbor.encode(Buffer.from(encryptionPassword))
  const [logN, r, p, salt, keystoreHash] = passwordHash.toString('utf8').split('|');
  const opts = {
    N: 2 ** Number(logN),
    r: Number(r),
    p: Number(p)
  };
  const encryptionHash = crypto
    .scryptSync(cborBytes, Buffer.from(salt, 'base64'), 32, opts)
    .toString('base64');

  return keystoreHash === encryptionHash;
}

// The keystore is "just" a CBOR-encoded 'UserSecret' as detailed below.
async function decodeKeystore(bytes, restoreParams) {
  return await cbor.decodeAll(bytes).then(async (obj) => {
    /**
     * The original 'UserSecret' from cardano-sl looks like this:
     *
     * ```hs
     * data UserSecret = UserSecret
     *     { _usVss       :: Maybe VssKeyPair
     *     , _usPrimKey   :: Maybe SecretKey
     *     , _usKeys      :: [EncryptedSecretKey]
     *     , _usWalletSet :: Maybe WalletUserSecret
     *     , _usPath      :: FilePath
     *     , _usLock      :: Maybe FileLock
     *     }
     *
     * data WalletUserSecret = WalletUserSecret
     *     { _wusRootKey    :: EncryptedSecretKey
     *     , _wusWalletName :: Text
     *     , _wusAccounts   :: [(Word32, Text)]
     *     , _wusAddrs      :: [(Word32, Word32)]
     *     }
     * ```
     *
     * We are interested in:
     * - usKeys:
     *    which is where keys have been stored since ~2018
     *
     * - usWalletSet
     *    which seems to have been used in earlier version; at least the
     *    wallet from the time did allow to restore so-called 'wallets'
     *    from keys coming from that 'WalletUserSecret'
     */
    const usKeys = obj[0][2].map((x) => toEncryptedSecretKey(x, "_usKeys", restoreParams));
    const usWalletSet = obj[0][3].map((x) => toEncryptedSecretKey(x[0], "_usWalletSet", restoreParams));

    // Shows all wallet when legacy address is not provided
    // or the wallet details if the legacy address belongs to the wallet
    // or does not show any wallet when the legacy address does not belong to any wallet.
    return (await Promise.all(usKeys.concat(usWalletSet))).filter((w) => w.isWalletAddress == true || w.isWalletAddress === undefined);
  });
}

function displayInformation(keystore) {
  const display = ({
    xprv,
    xpub,
    encryptedPayload,
    passphraseHash,
    isEmptyPassphrase,
    source,
    hasValidEncryption,
    encryptionPassword,
    isWalletAddress,
    path,
    addressFromDecryptedKey,
  }) => {
    return {
      "encrypted-root-private-key": encodeBech32("root_xsk", xprv),
      "root-public-key": encodeBech32("root_xvk", xpub),
      source,
      "is-empty-passphrase": isEmptyPassphrase,
      "has-valid-encryption": hasValidEncryption,
      // It can either be the user provided or empty if no encryption occured.
      "encryption-password": encryptionPassword,
      "is-wallet-address": isWalletAddress,
      "address-derivation-path": path,
      // It means either the address generated from the
      // - encrypted master private key or from the
      // - decrypted one.
      // It important when the paswhorHash has an empty passwordHash, but the
      // master private key does not regenerate the stored public key. That
      // means some glitch could happened in the past during the Daedalus
      // updates etc.
      "is-address-from-decrypted-key": addressFromDecryptedKey
    }
  };
  return JSON.stringify(keystore.map(display), null, 4);
}

function encodeBech32(prefix, bytes) {
  const words = bech32.toWords(bytes);
  const MAX_LENGTH = 999; // long-enough, Cardano uses bech32 for long strings.
  return bech32.encode(prefix, words, MAX_LENGTH);
}

// A master private key encryption is valid when the decrypted private key
// can regenerate the stored root public key.
async function isEncryptionValid(xprv, pub, isEmptyPassphrase, restoreParams) {
  // NOTE: Check whether that the stored master public key is the same
  // with the generated from the stored master private key.
  // This ensures that the master secret is not encrypted independently whether it
  // has an empty or non-empty password based hash.
  // This is enough as address derivation will do an additional check too.
  const isDecrypted = validatePublickey(xprv, pub)

  if (isDecrypted) {
    return {
      hasValidEncryption: true,
      decryptedSecret: xprv,
      encryptionPassword: ''
    }
  } else {

    // FIXME: Vacumlabs cardano memory combine seems stretching the user's password with blake2b_512.
    // Check what old cardano-wallet used and add the version of memory_combine too.
    const decrypted = await cardano.cardanoMemoryCombine(xprv, restoreParams.encryptionPassword)
    if (validatePublickey(decrypted, pub)) {
      return {
        hasValidEncryption: true,
        decryptedSecret: decrypted,
        encryptionPassword: restoreParams.encryptionPassword
      }
    } else {
      // It returns with the original xpriv
      return {
        hasValidEncryption: false,
        decryptedSecret: xprv,
        encryptionPassword: restoreParams.encryptionPassword
      }
    }
  }
}

// It returns undefined if the address is an empty string or invalid.
async function validateAddress(xpub, legacyAddress) {
  // This handles the undefined or empty string address
  try {
    const addrBuf = await cardano.addressToBuffer(legacyAddress)
    // derivation password
    const hdPassphrase = await cardano.xpubToHdPassphrase(xpub)
    const path = cardano.getBootstrapAddressDerivationPath(addrBuf, hdPassphrase)

    return {
      path: path,
      passPhrase: hdPassphrase
    }
  } catch (e) {
    return {
      path: [],
      passPhrase: undefined
    }
  }
}

// FIXME: Some old version of cardano-sl used the password for key derivation too.
function validateDerivedAddress(xprv, deriv, restoreParams) {
  // Byron addresses use V1 e.g. 1 scheme for validation
  const scheme = 1; // 1 for legacy, 2 for icarus.

  // Derive the addres keypair from the master secret key using the retrieved path
  // from the address and the legacy derivation scheme
  const addrXPrv = derivePrivAddrKey(xprv, deriv.path, scheme)
  const addrXpub = addrXPrv.slice(64, 128)

  const packedAddress = cardano.packBootstrapAddress(deriv.path, addrXpub, deriv.passPhrase, scheme, MAGIC)
  const generateAddress = cardano.base58.encode(packedAddress)
  return generateAddress == restoreParams.legacyAddress
}

function validatePublickey(xprv, pub) {
  const genPub = cardano.toPublic(xprv)
  return Buffer.compare(pub, genPub) == 0
}

// m/0'/0' is the derivation path for legacy (`Ddz...`) addresses.
// Icarus addresses (`Ae2...`) use BIP44
function derivePrivAddrKey(rootPriv, path, scheme) {
  const acct = cardano.derivePrivate(rootPriv, path[0], scheme)
  return cardano.derivePrivate(acct, path[1], scheme)
}